# Author: Rachel Oidtman
# Oidtman et al. 2019,


# this script estimates posterior distributions for mosquito splines

#=============================================================================#
# load data and libraries
#=============================================================================#


library('fda')
library('lubridate')
library('mvtnorm')

##### load & set up data
source('runFunctions_bayes.R')
mosq = read.csv('../data/guangzhou_vector_05-15.csv')
dat = read.csv('../data/guangzhou_case_weather_05-15.csv')


#=============================================================================#
# global variables
#=============================================================================#

# for MOI replace NA values w/ means from other years
ind.NA = which(is.na(mosq$MOI_pnas))
for(ii in 1:length(ind.NA)){
  mosq$MOI_pnas[ind.NA[ii]] = mean(mosq$MOI_pnas[which(mosq$Month==mosq$Month[ind.NA[ii]])], na.rm = T)
}
# set up MOI object
MOI = mosq$MOI_pnas

# for BI replace NA values w/ means from other years
ind.NA = which(is.na(mosq$BI))
for(ii in 1:length(ind.NA)){
  mosq$BI[ind.NA[ii]] = mean(mosq$BI[which(mosq$Month==mosq$Month[ind.NA[ii]])], na.rm = T)
}
# set up BI object
BI = mosq$BI
#####


##### set values
# polynomial order of spline
k = 3
set.order = 3
years = 2005:2015

# inputs for generate_spline
bs.in = create.bspline.basis(
  rangeval = c(1, nrow(dat)),
  nbasis = k * length(years),
  norder = set.order
)
# x.in = seq(0, nrow(dat), length.out = k * length(years))


# inputs for likelihood fxn
ind = list()
for(ii in 1:nrow(mosq)){
  ind[[ii]] = which(dat$year == mosq$Year[ii] & month(dat$date) == mosq$Month[ii])
}

# inputs for MCMC - initial values
sigma.moi = log(sd(MOI))
sigma.bi = log(sd(BI))
mu.bi = log(mean(BI) / mean(MOI))
y.in = rep(log(mean(MOI)), (k * length(years)))
initial.param = c(y.in, sigma.moi, sigma.bi, mu.bi)
sigma.param = diag(rep(0.01, length(initial.param))) ^ 2

#####


#=============================================================================#
# functions
#=============================================================================#

##### set up functions
# create daily spline for mosquito data
# input: y.in and GZ.data
# y.in takes mean MOI
# output: mosq.spline w/ set.order number of knots
generate_spline = function(y.in, dat){
  fd.params = y.in
  fd.bs = fd(
    coef = fd.params,
    basisobj = bs.in
  )
  mosq.spline = predict(fd.bs, 1:nrow(dat))
  return(mosq.spline)
}

# align monthly MOI with daily mosquito spline averaged over month 
# input: mosq.dat = mosquito data, mosq.spline = spline generated by generate_spline fxn
# output: monthly mean mosquito spline values
align_dates = function(mosq.spline, mosq.dat){
  mean.mosq.spline = sapply(1:nrow(mosq.dat), function(ii) mean(mosq.spline[ind[[ii]]]))
  return(mean.mosq.spline)
}

# likelihood
# input: mosq.spline = spline generated by generate_spline fxn
# global variables = sigma.moi, sigma.bi, mu.bi 
# output: log likelihood
log_lik = function(mean.mosq.spline, sigma.moi, mu.bi, sigma.bi){
  # browser()
  LL = 0
  
  LL.moi = dnorm(MOI, mean = exp(mean.mosq.spline), sd = exp(sigma.moi), log = TRUE)
  LL.bi = dnorm(BI, mean = exp(mu.bi) * exp(mean.mosq.spline), sd = exp(sigma.bi), log = TRUE)
  LL = LL + sum(LL.moi) + sum(LL.bi)
  
  return(LL)
}

# proposal draw from multivariate normal
# input: param.old = current parameters, sigma.in = covariance matrix
# output: randomly generated values for each knot 
proposal.draw = function(param.old, sigma.in){
  param.proposed = rmvnorm(1, param.old, makePositiveDefinite(sigma.in))
  return(param.proposed)
}

# proposal probability 
# input: param.old = current parameters, param.new = param.proposed, 
# sigma.in = covariance matrix
# output: probability 
proposal.prob = function(param.old, param.new, sigma.in){
  return(
    dmvnorm(param.new, param.old, makePositiveDefinite(sigma.in), log = TRUE))
}
#####


#=============================================================================#
# MCMC
#=============================================================================#


for(count in 1:3){
  
  
  ##### MCMC
  
  #################################
  ## start of burn in loop ## 
  burn.in = 1000
  
  mosq.spline = generate_spline(y.in = initial.param[1:(k * length(years))], dat)
  mean.mosq.spline = align_dates(mosq.dat = mosq, mosq.spline = mosq.spline)
  LL.current = log_lik(mean.mosq.spline, sigma.moi = sigma.moi, sigma.bi = sigma.bi, mu.bi = mu.bi)
  
  # initialize param.current
  param.current = initial.param
  
  for(ii in 2:burn.in){
    param.proposed = proposal.draw(param.current, sigma.param)
    
    
    mosq.spline = generate_spline(as.numeric(param.proposed[1:(k * length(years))]), dat)
    mean.mosq.spline = align_dates(mosq.dat = mosq, mosq.spline = mosq.spline)
    LL.proposed = log_lik(mean.mosq.spline = mean.mosq.spline, 
                          sigma.moi = param.proposed[(k*length(years) + 1)],
                          sigma.bi = param.proposed[(k*length(years) + 2)],
                          mu.bi = param.proposed[(k*length(years) + 3)])
    
    acceptance.prob = LL.proposed - LL.current +
      proposal.prob(param.current, param.proposed, sigma.param) - 
      proposal.prob(param.proposed, param.current, sigma.param)
    
    if(runif(1) < exp(acceptance.prob)){
      param.current = param.proposed
      LL.current = LL.proposed
    }
  }
  param.burn = param.current
  
  #################################
  ## start of build up cov mat loop ## 
  
  mosq.spline = generate_spline(y.in = param.burn[1:(k * length(years))], dat)
  mean.mosq.spline = align_dates(mosq.dat = mosq, mosq.spline = mosq.spline)
  LL.current = log_lik(mean.mosq.spline = mean.mosq.spline, 
                       sigma.moi = param.burn[(k*length(years) + 1)],
                       sigma.bi = param.burn[(k*length(years) + 2)],
                       mu.bi = param.burn[(k*length(years) + 3)])
  
  # define number of times to repeat adaptive sampling and chain length
  loop.reps = 3
  chain.length = 1000
  
  # allocate array to store all of the param values
  param.chain.cov = array(0, dim = c(chain.length, length(initial.param), loop.reps))
  param.chain.cov[1, , 1] = param.burn
  
  acceptance.rate.cov = numeric(0)
  
  param.init = matrix(0, nrow = loop.reps + 1, ncol = length(initial.param))
  param.init[1, ] = param.burn
  
  for(jj in 1:loop.reps){
    param.current = param.init[jj, ] 
    
    for(ii in 2:chain.length){
      accepted = rejected = 0
      param.proposed = proposal.draw(param.current, sigma.param)
      
      mosq.spline = generate_spline(as.numeric(param.proposed[1:(k * length(years))]), dat)
      mean.mosq.spline = align_dates(mosq.dat = mosq, mosq.spline = mosq.spline)
      LL.proposed = log_lik(mean.mosq.spline = mean.mosq.spline, 
                            sigma.moi = param.proposed[(k*length(years) + 1)],
                            sigma.bi = param.proposed[(k*length(years) + 2)],
                            mu.bi = param.proposed[(k*length(years) + 3)])
      
      acceptance.prob =
        LL.proposed - 
        LL.current +
        proposal.prob(param.current, param.proposed, sigma.param) - 
        proposal.prob(param.proposed, param.current, sigma.param)
      
      if(runif(1) < exp(acceptance.prob)){
        param.current = param.proposed
        LL.current = LL.proposed
        accepted = accepted + 1
      }
      else{
        rejected = rejected + 1
      }
      param.chain.cov[ii, , jj] = param.current
    }
    param.init[jj + 1, ] = param.current
    acceptance.rate.cov = c(acceptance.rate.cov, 
                            accepted / (accepted + rejected))
    
    sigma.param = (2.38 ^ 2) * cov(param.chain.cov[ , , jj]) / length(initial.param)
  }
  param.cov = param.current
  
  #################################
  ## start final mcmc ## 
  
  # set up likelihood for last value in previous loop
  mosq.spline = generate_spline(y.in = param.cov[1:(k * length(years))], dat)
  mean.mosq.spline = align_dates(mosq.dat = mosq, mosq.spline = mosq.spline)
  LL.current = log_lik(mean.mosq.spline = mean.mosq.spline, 
                       sigma.moi = param.cov[(k*length(years) + 1)],
                       sigma.bi = param.cov[(k*length(years) + 2)],
                       mu.bi = param.cov[(k*length(years) + 3)])
  
  # define number of iterations of MCMC and frequency of recording
  chain.length = 2000
  chain.freq = 20
  
  # allocate vectors to store chains for each parameter
  param.chain = matrix(0, nrow = chain.length, ncol = length(initial.param))
  
  acceptance.rate = numeric(0)
  
  # iterate through each step in the chain
  for(ii in 1:chain.length){
    accepted = rejected = 0
    
    for(jj in 1:chain.freq){
      # draw a proposed jump for which.param
      param.proposed = proposal.draw(param.current, sigma.param)
      
      mosq.spline = generate_spline(as.numeric(param.proposed[1:(k * length(years))]), dat)
      mean.mosq.spline = align_dates(mosq.dat = mosq, mosq.spline = mosq.spline)
      LL.proposed = log_lik(mean.mosq.spline = mean.mosq.spline, 
                            sigma.moi = param.proposed[(k*length(years) + 1)],
                            sigma.bi = param.proposed[(k*length(years) + 2)],
                            mu.bi = param.proposed[(k*length(years) + 3)])
      
      # calculate acceptance probability of accepting the jump
      acceptance.prob =
        LL.proposed -
        LL.current +
        proposal.prob(param.current, param.proposed, sigma.param) - 
        proposal.prob(param.proposed, param.current, sigma.param)
      
      # determine whether to take the jump and update accordingly
      if(runif(1) < exp(acceptance.prob)){
        param.current = param.proposed
        LL.current = LL.proposed
        accepted = accepted + 1
      } else{
        rejected = rejected + 1
      }
    }
    # save the current state to the chain of record
    # add sliding window acceptance rate here
    param.chain[ii, ] = param.current
    acceptance.rate = c(acceptance.rate, 
                        accepted / (accepted + rejected))
    
    # write to file
    eval(parse(text=paste('
                          save(acceptance.rate, param.chain,
                          file = "../output/mosquito_mcmc_', count, '.RData")',sep='')))
  }
}



